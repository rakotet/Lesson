1) Все компаненты должны возвращать один элемент (к примеру <div></div> или можно обернуть в <></> так тоже будет работать)
2) На React css пишется в КамелКейсе, классы пишутся не class="" а className=""
3) И название css классов должны начинаться в имени компанента в котором он используется, так не будет путаницы с названиями css
4) В JSX style пишется через {{}} объект: style={{color: 'red', fontFamily: 'Georgia'}} другой js просто в {}
Например, HTML <ul style="background-color: black"> будет написан так, как <ul style={{ backgroundColor: 'black' }}>
5) Компаненты должны являться чистыми функциями (не затрагивать переменные вне своей зоны видимости компанента, и возвращать тот же тип данных что и принимать)
6) Когда выводим одинаковые элементы через цикл, map или filter нужно указывать уникальный key для каждого элемента (брать из данных)
7) Нельзя менять переменную состояние напрямую, только через ф-ю изменения состояния хука useState
8) Ф-и обработчики действий не вызываются а передаются <button onClick={handleClick}> либо если ф-я сразу в обработчике то через анонимную ф-ю <button onClick={() => alert('You clicked me!')}>
9) children если забыл посмотри в документации, важная вещь
import Avatar from './Avatar.js';

function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}

export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{ 
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2'
        }}
      />
    </Card>
  );
}

10) Компаненты react должны начинаться с заглавной буквы!!!
11) Ни в коем случае нельзя определять компанент внутри другого компанента!
12) Экспорт Именованный	export function Button(){} -	import { Button } from './Button.js'; таких сколько угодно в файле
13) Экспорт По умолчанию	export default function Button(){} - import Button from './Button.js'; только один на файл
14) По историческим причинам aria-*атрибуты data-*пишутся как в HTML с тире, а не в камелкейсе
15) Все теги в React должны закрываться 
16) Про пропсы:
function Avatar(props) {
  let person = props.person;
  let size = props.size;
  // ...
}

Тоже самое но с диструктаризацией (arr = [1, 2]; let [one, two] = arr присваиваем значение one это теперь 1 и two теперь 2), так и надо делать:

function Avatar({ person, size }) {
  // ...
}

Указание значения props по умолчанию, если его не передали:

function Avatar({ person, size = 100 }) {
  // ...
}

17) Условные рендеринг можно использовать if() или тернарный оператор:
function Item({ name, isPacked }) {
  if (isPacked) {
    return <li className="item">{name} ✔</li>;
  }
  return <li className="item">{name}</li>;
}

Тоже самое но через тернарный:

return (
  <li className="item">
    {isPacked ? name + ' ✔' : name}
  </li>
);

Тоже самое через оператор  &&

return (
  <li className="item">
    {name} {isPacked && '✔'}
  </li>
);

18) События в React распространяются от элемента гды было вызвано событие и в верх по дереву DOM и если там мы перехватываем такой же тип события то оно тоже сработает. 
Можно отменить распростронение событий ф-й stopPropagation();

function Button({ onClick, children }) {
  return (
    <button onClick={e => {
      e.stopPropagation();
      onClick();
    }}>
      {children}
    </button>
  );
}

Отменить стандартные действия браузера так же как и в обычном js ф-я preventDefault();

export default function Signup() {
  return (
    <form onSubmit={e => {
      e.preventDefault();
      alert('Submitting!');
    }}>
      <input />
      <button>Send</button>
    </form>
  );
}

19) Хуки — функции, начинающиеся с use— можно вызывать только на верхнем уровне ваших компонентов или ваших собственных хуков. Вы не можете вызывать хуки внутри условий, циклов или других вложенных функций
20) В одном компоненте вы можете иметь столько переменных состояния и любого типа, сколько захотите. 
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

21) Состояние является локальным для экземпляра компонента на экране. Другими словами, если вы визуализируете один и тот же компонент дважды, каждая копия будет в полностью изолированном состоянии! Изменение одного из них не повлияет на другой. Родительский компонент не может его изменить
22) Существует две причины для рендеринга компонента:
  Это первоначальный рендер компонента .
  Состояние компонента (или одного из его предков) обновлено.
23) После запуска рендеринга React вызывает ваши компоненты, чтобы выяснить, что отображать на экране. «Рендеринг» — это вызов ваших компонентов в React.
  При первоначальном рендеринге React вызовет корневой компонент.
  Для последующих рендерингов React будет вызывать компонент функции, обновление состояния которого инициировало рендеринг.
24) Очень важная особоенность!!! Если хотим менять состояние (state) несколько раз за один рендер, то нужно использовать стрелочную ф-ю для получения верного текущего значения состояния:

  const [score, setScore] = useState(0);

    function increment() { - верно 
    setScore(s => s + 1);
  }

function increment() { - НЕ верно 
    setScore(score + 1);
  }

  Работает так и для асинхронного кода!!!

  React сохраняет значения состояния «фиксированными» в обработчиках событий одного рендеринга. 

25) Установка переменной состояния поставит в очередь еще один рендеринг. Но иногда вам может потребоваться выполнить несколько операций над значением, прежде чем поставить в очередь следующий рендеринг. Для этого полезно понять, как пакеты React обновляют состояние.

Реакт ждет изменения состояния всех компанентов и только потом рендерит пользователю интернет, что и дает быстродействие, поэтому если изменять состояние без стрелочной ф-и то будет попадать в изменение только последний вызов setState

26) Состояние может содержать любое значение JavaScript, включая объекты. Но вам не следует напрямую изменять объекты, которые вы держите в состоянии React. Вместо этого, когда вы хотите обновить объект, вам нужно создать новый (или сделать копию существующего), а затем установить состояние для использования этой копии.

Теперь рассмотрим объект в состоянии:

const [position, setPosition] = useState({ x: 0, y: 0 });
Технически изменить содержимое самого объекта можно . Это называется мутацией:

position.x = 5;
Однако, хотя объекты в состоянии React технически изменяемы, с ними следует обращаться так, как если бы они были неизменяемыми — например, с числами, логическими значениями и строками. Вместо того, чтобы мутировать их, вам всегда следует заменять их.

setPosition({
          x: e.clientX,
          y: e.clientY
        });

Вы должны рассматривать значение состояния, к которому у вас есть доступ при рендеринге, как доступное только для чтения.

Но такой код абсолютно хорош , потому что вы изменяете только что созданный новый объект :
const nextPosition = {};
nextPosition.x = e.clientX;
nextPosition.y = e.clientY;
setPosition(nextPosition);

Надежный способ добиться желаемого поведения — создать новый объект и передать его в setPerson. Но здесь вы также хотите скопировать в него существующие данные, потому что изменилось только одно из полей:

setPerson({
  firstName: e.target.value, // New first name from the input
  lastName: person.lastName,
  email: person.email
});

Вы можете использовать синтаксис ... распространения объектов , чтобы вам не приходилось копировать каждое свойство отдельно.

setPerson({
  ...person, // Copy the old fields
  firstName: e.target.value // But override this one
});

Вы также можете использовать фигурные скобки [и ]внутри определения объекта, чтобы указать свойство с динамическим именем. Вот тот же пример, но с одним обработчиком событий вместо трех разных:

import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleChange(e) {
    setPerson({
      ...person,
      [e.target.name]: e.target.value
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          name="firstName"
          value={person.firstName}
          onChange={handleChange}
        />
      </label>
      <label>
        Last name:
        <input
          name="lastName"
          value={person.lastName}
          onChange={handleChange}
        />
      </label>
      <label>
        Email:
        <input
          name="email"
          value={person.email}
          onChange={handleChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}

Для упрощения создания новых объектов для изменения состояния, если эти объекты с глубокой вложеностью можно использовать библиотеку npm install immer use-immer, которая это существенно упрощает https://github.com/immerjs/use-immer

Массивы изменяемы в JavaScript, но при хранении в состоянии их следует рассматривать как неизменяемые. Как и в случае с объектами, когда вы хотите обновить массив, хранящийся в состоянии, вам необходимо создать новый (или сделать копию существующего), а затем установить состояние для использования нового массива.

В JavaScript массивы — это просто еще один тип объектов. Как и в случае с объектами , массивы в состоянии React следует рассматривать как доступные только для чтения. Это означает, что вам не следует переназначать элементы внутри массива, например arr[0] = 'bird', а также не следует использовать методы, изменяющие массив, например push()и pop().

Синтаксис расширения массива также позволяет добавлять элемент, помещая его перед оригиналом ...artists:

setArtists([
  { id: nextId++, name: name },
  ...artists // Put old items at the end
]);
Таким образом, распространение может выполнять как push()добавление в конец массива, так unshift()и добавление в начало массива. Попробуйте это в песочнице выше!

Удаление из массива
Самый простой способ удалить элемент из массива — отфильтровать его . Другими словами, вы создадите новый массив, который не будет содержать этот элемент. Для этого используйте filterметод

27) React будет сохранять состояние до тех пор, пока вы визуализируете один и тот же компонент в одной и той же позиции. 
  Обратите внимание, как в тот момент, когда вы прекращаете рендеринг второго счетчика, его состояние полностью исчезает. Это потому, что когда React удаляет компонент, он разрушает его состояние.

  React сохраняет состояние компонента до тех пор, пока он отображается на своей позиции в дереве пользовательского интерфейса. Если он удаляется или в той же позиции отображается другой компонент, React отбрасывает его состояние.

  Тот же компонент в той же позиции сохраняет состояние, даже если его заменили на такой же компанент но новый.

  Как правило, если вы хотите сохранить состояние между повторными рендерингами, структура вашего дерева должна «совпадать» от одного рендеринга к другому. Если структура отличается, состояние уничтожается, потому что React уничтожает состояние, когда удаляет компонент из дерева.

  Существует также другой, более общий способ сбросить состояние компонента.
  Возможно, вы видели keys при рендеринге списков. Ключи предназначены не только для списков! Вы можете использовать ключи, чтобы React различал любые компоненты. По умолчанию React использует порядок внутри родителя («первый счетчик», «второй счетчик»), чтобы различать компоненты. Но ключи позволяют вам сообщить React, что это не просто первый или второй счетчик , а конкретный счетчик — например, счетчик Тейлора . Таким образом, React будет знать счетчик Тейлора , где бы он ни появился в дереве!

  {isPlayerA ? (
    <Counter key="Taylor" person="Taylor" />
  ) : (
    <Counter key="Sarah" person="Sarah" />
  )}

28) Обычно вы передаете информацию от родительского компонента дочернему компоненту через реквизиты. Но передача реквизитов может стать многословной и неудобной, если вам приходится передавать их через множество компонентов посередине или если многим компонентам вашего приложения требуется одна и та же информация. Контекст позволяет родительскому компоненту сделать некоторую информацию доступной любому компоненту в дереве ниже него — независимо от глубины — без явной передачи ее через реквизиты.
https://react.dev/learn/passing-data-deeply-with-context

29) Если вы хотите, чтобы компонент «запоминал» некоторую информацию, но вы не хотите, чтобы эта информация запускала новые рендеры , вы можете использовать ref

ref тоже что и state только при изменении не вызывает новый рендер компанента

30) 