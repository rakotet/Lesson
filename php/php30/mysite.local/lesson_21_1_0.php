<?php
  $reg = '/a . b/'; // . - ожидает любой символ кроме перехода на новую строку
  $str = 'a . b';
  echo preg_match($reg, $str),'<br />';

  $reg = '/^ab/'; // ^ - ожидает начало строки
  $str = 'abasa';
  echo preg_match($reg, $str),'<br />';

  $reg = '/ab$/'; // $ - ожидает конец строки
  $str = 'asaab';
  echo preg_match($reg, $str),'<br />';

  $reg = '/a [a-z][0-3] b$/'; // [] - ожидает указанную внутри группу символов от и до
  $str = '123a s3 b';
  echo preg_match($reg, $str),'<br />';

  $reg = '/a [^a-z]/'; // [^] - ожидает всё что угодно кроме того что в скобках
  $str = '123a 3 b';
  echo preg_match($reg, $str),'<br />';

  $reg = '/a ([a-z]b\d) (b)$/'; // () - объеденяет группу как бы в один элемент, всё что находится в них и соответствует рег.выражению добавляется в конец массива с совпадениями, одна () один элемент в массиве, по сути могут из строки вытащить нужные данные
  $str = '123a db4 b';
  echo preg_match($reg, $str, $matches),'<br />';
  print_r($matches);
  echo '<br />';

  $reg = '/a ([a-z]a)* b/'; // * - модификатор повторения, означает что символ или если () то группа символов может повторяться от 0 до бесконечности раз
  $str = 'a  b';
  $str2 = 'a sa da ra b';
  echo preg_match($reg, $str),'<br />';
  echo preg_match($reg, $str2),'<br />';

  $reg = '/a ([a-z]a)+ b/'; // + - тоже модификатор повторения, но должно повториться хотя бы один и более раз в отличии от *
  $str = 'sds a fa b 5454';
  echo preg_match($reg, $str),'<br />';

  $reg = '/a q? b/'; // ? - тоже модификатор повторения, но должно повториться один или ноль раз
  $str = 'a q b';
  $str = 'a  b';
  echo preg_match($reg, $str),'<br />';

  $reg = '/a \d{2} b/'; // {число} - тоже модификатор повторения, указывает точно какое количество повторений должно быть
  $str = 'a 35 b';
  echo preg_match($reg, $str),'<br />';

  $reg = '/a \d{2,} b/'; // {число,} - тоже модификатор повторения, указывает какое минимальное количество повторений должно быть
  $str = 'a 353545 b';
  echo preg_match($reg, $str),'<br />';

  $reg = '/a \d{2,5} b/'; // {число,число} - тоже модификатор повторения, указывает какое минимальное и максимальное количество повторений должно быть
  $str = 'a 353 b';
  echo preg_match($reg, $str),'<br />';

  /////////////// Особые модификаторы можно как угодно комбенировать в одном рег. выражении

  $reg = '/a \d b/i'; // i - особый модификатор всего рег.выражения ставится за рег. выражением, означает игнорировать регистр
  $str = 'A 3 B';
  echo preg_match($reg, $str),'<br />';

  $reg = '/Л \d Д/u'; // u - особый модификатор всего рег.выражения ставится за рег. выражением, необходим для работы с кирилицей !!!
  $str = 'Л 3 Д';
  echo preg_match($reg, $str),'<br />';

  $reg = '/a\s\d          b/ix'; // x - игнорирует все пробелы (как будто их стирает)
  $str = 'A 3B';
  echo preg_match($reg, $str),'<br />';

  $reg = '/ab$/m'; // m - воспринимает строку как многострочный текст где каждая строка заканчивается переходом на новую строку \n
  $str = "ab\nddd";
  echo preg_match($reg, $str),'<br />';

  $reg = '/ab$/s'; // s - воспринимает многострочный текст как единую одну строку
  $str = "a1\nddab";
  echo preg_match($reg, $str),'<br />';

  $reg = '#/#'; // Вариант поиска / в строке, это заменить границы рег.выражения на другой символ
  $str = '/';
  echo preg_match($reg, $str),'<br />';

  $reg = '/\//'; // Вариант поиска / в строке, экранировать нужный символ
  $str = '/';
  echo preg_match($reg, $str),'<br />';

  $reg = '/a\.b/'; // Экранирование . что бы воспринималась как символ а не модификатор
  $str = 'a.b';
  echo preg_match($reg, $str),'<br />';

  ////////// Жадность квантификаторов

  $reg = '/"(.+?)"/'; // рег выражение пропускает и записывает в массив всё что находится в "", ? рядом с модификатором ограничивает его жадность (не будет забирать всю строку от одних ковычек до других)
  $str = 'Текст "нужно" ещё что то "и это тоже нужно"';
  echo preg_match_all($reg, $str, $matches),'<br />'; // нужно использовать именно preg_match_all когда ищим больше одного одинакового совпадения для записи в массив
  print_r($matches);
  echo '<br />';

  foreach($matches[1] as $v) echo $v.'<br />'; // дальше уже можно работать с ним как с обычным массивом, а значение этого массива мы вырезали из строки использую рег. выражение выше


?>